//
//  GDMapInView.swift
//  zjlao
//
//  Created by WY on 2019/8/18.
//  Copyright ¬© 2019Âπ¥ jianlei. All rights reserved.
//



import UIKit
import MapKit
class GDMapInView: UIView{
    var mapView : DDMapView = DDMapView()
    var needGobackCenter = true
     var camera = MKMapCamera.init()
    var mapDidEndMove:(()->())?
    override init(frame: CGRect) {
        super.init(frame: frame)
        self.setupSubViews()
    }
    deinit {
        mylog("ü§©GDMapInView destroyed")
    }
    required init?(coder aDecoder: NSCoder) {
        fatalError("init(coder:) has not been implemented")
    }
    func setupSubViews()  {
        self.setupMapView()
    }
    override func layoutSubviews() {
        super.layoutSubviews()
        self.mapView.frame = self.bounds
    }
    override func didMoveToSuperview() {
        if self.superview != nil  {
        }
    }

    func setupMapView()  {
        
        self.mapView.frame =  self.bounds
        self.mapView.showsUserLocation = true

        self.mapView.delegate = self
        if #available(iOS 9.0, *) {
            self.mapView.showsScale = true
        } else {
            // Fallback on earlier versions
        }//ÊØî‰æãÂ∞∫
        if #available(iOS 9.0, *) {
            self.mapView.showsTraffic = false
        } else {
            // Fallback on earlier versions
        }
        if #available(iOS 9.0, *) {
            self.mapView.showsCompass = true
        } else {
            // Fallback on earlier versions
        }
//        map.userLocation//Áî®Êà∑ÂΩìÂâç‰ΩçÁΩÆ
        self.mapView.mapType = MKMapType.standard
        self.addSubview(self.mapView)
    }
    func addPlaceMark( location: GDLocation)  {
        self.mapView.addAnnotation(location)
        
    }
    func addPlaceMarks( locations: [GDLocation])  {
        self.mapView.addAnnotations(locations)
    }
    func addPlaceMarkWithCoornidate(coornidate: CLLocationCoordinate2D)  {
        let userLocation = GDLocation.init()
        mylog(self.mapView.annotations.count)//Â¶ÇÊûúÊòæÁ§∫ÂΩìÂâç‰ΩçÁΩÆÁöÑËØù , count Ëá≥Â∞ë‰∏∫1
        if self.mapView.showsUserLocation {
            if self.mapView.annotations.count % 2 ==  0 {
                userLocation.type = GDLocationType.origen
            }else {
                userLocation.type = GDLocationType.image1
            }
        }else{
            if self.mapView.annotations.count % 2 ==  0 {
                userLocation.type = GDLocationType.origen
            }else {
                userLocation.type = GDLocationType.image1
            }
        }
        userLocation.coordinate = coornidate
//        userLocation.title = "title"
//        userLocation.subtitle = "subTitle"
        let location = CLLocation.init(latitude: userLocation.coordinate.latitude, longitude: userLocation.coordinate.longitude)
        DDLocationManager.share.geoCoder.reverseGeocodeLocation(location) { (arr , error ) in
            let placeMark = arr?.first
//            userLocation.title = placeMark?.country
//            userLocation.subtitle = placeMark?.name
            mylog("country->\(placeMark?.country)")
            mylog("name->\(placeMark?.name)")
            mylog("administrativeArea->\(placeMark?.administrativeArea)")
            mylog("locality->\(placeMark?.locality)")
            mylog("ocean->\(placeMark?.ocean)")
            mylog("postalCode->\(placeMark?.postalCode)")
            mylog("subAdministrativeArea->\(placeMark?.subAdministrativeArea)")
            mylog("subLocality->\(placeMark?.subLocality)")
            mylog("subThoroughfare->\(placeMark?.subThoroughfare)")
            mylog("thoroughfare->\(placeMark?.thoroughfare)")
            /*
             country->Optional("‰∏≠ÂõΩ")//ÂõΩÂÆ∂
             name->Optional("Áúã‰∏πË∑Ø39Âè∑")//ÊúÄÂ∞èÂçï‰ΩçÂú∞ÂùÄ,ÂèØËÉΩÊòØ‰∏™ÂÖ¨Âè∏Âêç,‰πüÂèØËÉΩË∑üË°óÈÅìÈáçÂ§ç
             administrativeArea->Optional("Âåó‰∫¨Â∏Ç")//ÁúÅ‰ªΩ
             locality->Optional("Âåó‰∫¨Â∏Ç") // Â∏Ç
             ocean->nil // ÂΩìÂùêÊ†áÂú®Êµ∑ÈáåÁöÑÊó∂ÂÄôÊâçÊúâÂÄº , Â¶ÇÊ∏§Êµ∑
             postalCode->nil
             subAdministrativeArea->nil
             subLocality->Optional("‰∏∞Âè∞Âå∫")//Âå∫
             subThoroughfare->Optional("39Âè∑")
             thoroughfare->Optional("Áúã‰∏πË∑Ø")//Ë°óÈÅì
             */
        }
        //        self.mapView?.addAnnotation((self.mapView?.userLocation)!)
        //            self.mapView?.showAnnotations([userLocation], animated: true)
        self.mapView.addAnnotation(userLocation)
        //                self.mapView?.removeAnnotation(<#T##annotation: MKAnnotation##MKAnnotation#>)
        //        self.mapView?.annotations//Â§ßÂ§¥ÈíàÊï∞ÁªÑ
        //        }
        
    }
    
    func addPlaceMarkWithTouches(touches: Set<UITouch>)  {
        let touch : UITouch = touches.first!;
        let point =  touch.location(in: self.mapView)
        let coornidate =  self.mapView.convert(point, toCoordinateFrom: self.mapView)
        let userLocation = GDLocation.init()
        mylog(self.mapView.annotations.count)//Â¶ÇÊûúÊòæÁ§∫ÂΩìÂâç‰ΩçÁΩÆÁöÑËØù , count Ëá≥Â∞ë‰∏∫1
        if self.mapView.showsUserLocation {
            if self.mapView.annotations.count % 2 ==  0 {
                userLocation.type = GDLocationType.origen
            }else {
                userLocation.type = GDLocationType.image1
            }
        }else{
            if self.mapView.annotations.count % 2 ==  0 {
                userLocation.type = GDLocationType.origen
            }else {
                userLocation.type = GDLocationType.image1
            }
        }
        userLocation.coordinate = coornidate
//        userLocation.title = "title"
//        userLocation.subtitle = "subTitle"
        let location = CLLocation.init(latitude: userLocation.coordinate.latitude, longitude: userLocation.coordinate.longitude)
        DDLocationManager.share.geoCoder.reverseGeocodeLocation(location) { (arr , error ) in
            let placeMark = arr?.first
//            userLocation.title = placeMark?.country
//            userLocation.subtitle = placeMark?.name
            mylog("country->\(placeMark?.country)")
            mylog("name->\(placeMark?.name)")
            mylog("administrativeArea->\(placeMark?.administrativeArea)")
            mylog("locality->\(placeMark?.locality)")
            mylog("ocean->\(placeMark?.ocean)")
            mylog("postalCode->\(placeMark?.postalCode)")
            mylog("subAdministrativeArea->\(placeMark?.subAdministrativeArea)")
            mylog("subLocality->\(placeMark?.subLocality)")
            mylog("subThoroughfare->\(placeMark?.subThoroughfare)")
            mylog("thoroughfare->\(placeMark?.thoroughfare)")
            /*
             country->Optional("‰∏≠ÂõΩ")//ÂõΩÂÆ∂
             name->Optional("Áúã‰∏πË∑Ø39Âè∑")//ÊúÄÂ∞èÂçï‰ΩçÂú∞ÂùÄ,ÂèØËÉΩÊòØ‰∏™ÂÖ¨Âè∏Âêç,‰πüÂèØËÉΩË∑üË°óÈÅìÈáçÂ§ç
             administrativeArea->Optional("Âåó‰∫¨Â∏Ç")//ÁúÅ‰ªΩ
             locality->Optional("Âåó‰∫¨Â∏Ç") // Â∏Ç
             ocean->nil // ÂΩìÂùêÊ†áÂú®Êµ∑ÈáåÁöÑÊó∂ÂÄôÊâçÊúâÂÄº , Â¶ÇÊ∏§Êµ∑
             postalCode->nil
             subAdministrativeArea->nil
             subLocality->Optional("‰∏∞Âè∞Âå∫")//Âå∫
             subThoroughfare->Optional("39Âè∑")
             thoroughfare->Optional("Áúã‰∏πË∑Ø")//Ë°óÈÅì
             */
        }
        //        self.mapView?.addAnnotation((self.mapView?.userLocation)!)
        //            self.mapView?.showAnnotations([userLocation], animated: true)
        self.mapView.addAnnotation(userLocation)
//                self.mapView?.removeAnnotation(<#T##annotation: MKAnnotation##MKAnnotation#>)
//        self.mapView?.annotations//Â§ßÂ§¥ÈíàÊï∞ÁªÑ
        //        }

    }
    
    // MARK: Ê≥®Èáä : ÂØºËà™ÂàíÁ∫ø
    func drawLineMethod(sourceCoordinate : CLLocationCoordinate2D , destinationCoordinate : CLLocationCoordinate2D , transportType: MKDirectionsTransportType =  MKDirectionsTransportType.any)  {
        let tempRequest = MKDirections.Request.init()
            tempRequest.transportType = transportType
            tempRequest.source = MKMapItem.init(placemark: MKPlacemark.init(coordinate: sourceCoordinate , addressDictionary:nil ))
            tempRequest.destination = MKMapItem.init(placemark: MKPlacemark.init(coordinate: destinationCoordinate, addressDictionary:nil ))
            let tempDerection : MKDirections = MKDirections.init(request: tempRequest)
            tempDerection.calculate(completionHandler: { (resp, error ) in
                if error == nil {
                    if let route = resp?.routes.last{
                        self.mapView.addOverlays([route.polyline])
                    }else{
                        mylog("error")
                    }
                }else{
                    mylog(error)
                }
                /*
                 resp'properties:
                 let routes : [MKRoute]= respons?.routes//Á∫øË∑ØÊï∞ÁªÑ(Â§öÁßçÊñπÊ°à)
                 let route = routes.first
                 route.name : Á∫øË∑ØÂêçÁß∞
                 route.distance : Ë∑ùÁ¶ª
                 expectedTravelTime : ËØ≠Âè•Êó∂Èó¥
                 polyline : ÊäòÁ∫ø(Êï∞ÊçÆÊ®°Âûã)
                 let steps : [MKRouteStep] = route.first.steps
                 let step = steps.first
                 step.instructions : ÂØºËà™ÊèêÁ§∫ËØ≠
                 */

            })
    }

    ///
    
    ////delegate 
    
    ////
    
    //MARK: Ëé∑Âèñ‰∏§‰∏™ÂùêÊ†á‰πãÈó¥ÁöÑË∑ØÁ∫øresp?.routes
    func getRoutes(sourceCoordinate : CLLocationCoordinate2D , destinationCoordinate : CLLocationCoordinate2D , complate : @escaping (_ response : MKDirections.Response? )->())  {
        if #available(iOS 10.0, *) {
            let tempRequest = MKDirections.Request.init()
            tempRequest.source = MKMapItem.init(placemark: MKPlacemark.init(coordinate: sourceCoordinate))
            tempRequest.destination = MKMapItem.init(placemark: MKPlacemark.init(coordinate: destinationCoordinate))
            let tempDerection : MKDirections = MKDirections.init(request: tempRequest)
            tempDerection.calculate(completionHandler: { (resp, error ) in
                if error != nil {complate(nil) ;return}
                /*
                 resp'properties:
                 let routes : [MKRoute]= respons?.routes//Á∫øË∑ØÊï∞ÁªÑ(Â§öÁßçÊñπÊ°à)
                 let route = routes.first
                 route.name : Á∫øË∑ØÂêçÁß∞
                 route.distance : Ë∑ùÁ¶ª
                 expectedTravelTime : ËØ≠Âè•Êó∂Èó¥
                 polyline : ÊäòÁ∫ø(Êï∞ÊçÆÊ®°Âûã)
                 let steps : [MKRouteStep] = route.first.steps
                 let step = steps.first
                 step.instructions : ÂØºËà™ÊèêÁ§∫ËØ≠
                 */
                    complate(resp)
            })
        } else {
            // Fallback on earlier versions
            complate(nil)
        }
    }
   
    //ÊâßË°åÂàíÁ∫ø
    func performDrawLint (polyline: MKPolyline)  {
        self.mapView.addOverlay(polyline)
    }

    
    
    
    
    // MARK: Ê≥®Èáä : Ëé∑ÂèñÂú∞ÂõæÊà™Âõæ
    func getshotScreen() {
        let options = MKMapSnapshotter.Options()
        //options.size = CGSize(width: 200, height: 200)
        let snapShotter  : MKMapSnapshotter = MKMapSnapshotter.init(options: options)
        snapShotter.start { (snapShot, error ) in
            mylog(snapShot?.image)
        }
    }
    
    // MARK: Ê≥®Èáä : 3DËßÜËßí
    func setup3D()  {
        
        let camera = MKMapCamera.init(lookingAtCenter: CLLocationCoordinate2D.init(latitude: self.mapView.centerCoordinate.latitude, longitude: self.mapView.centerCoordinate.longitude), fromEyeCoordinate: CLLocationCoordinate2D.init(latitude: self.mapView.centerCoordinate.latitude - 0.005, longitude: self.mapView.centerCoordinate.longitude), eyeAltitude: 21.0)//3DËßÜËßí
        self.camera = camera
        self.mapView.setCamera(camera, animated: true)
    }

    //ÂÆûÊó∂ËÆæÁΩÆ‰ΩçÁΩÆÂà∞Â±èÂπï‰∏≠ÂøÉ
    func settheUserLocationToScreenCenter(location: MKUserLocation)  {
        mapView.setCenter(location.coordinate, animated: true)//ËÆæÁΩÆÂΩìÂâç‰ΩçÁΩÆÂà∞Â±èÂπï‰∏≠ÂøÉ
        let span :  MKCoordinateSpan = MKCoordinateSpan.init(latitudeDelta: 0.010001, longitudeDelta: 0.010001)//ÂàùÂßãÊòæÁ§∫ËåÉÂõ¥,ÂÄºË∂äÂ∞èË∂äÁ≤æÁ°Æ
        let  region: MKCoordinateRegion = MKCoordinateRegion.init(center:location.coordinate, span: span)
        mapView.setRegion(region, animated: true)//ÂΩìregionÊîπÂèòÁöÑÊó∂ÂÄôËÆæÁΩÆËøô‰∫õ
    }

    
}


extension GDMapInView :  MKMapViewDelegate {
    
    // MARK: Ê≥®Èáä : (ÂàíÁ∫øÁî®ÁöÑ‰ª£ÁêÜÊñπÊ≥ï)Ê∑ªÂä†Ë¶ÜÁõñÂ±ÇÂêéË∞ÉÁî®
    func mapView(_ mapView: MKMapView, rendererFor overlay: MKOverlay) -> MKOverlayRenderer{
        if overlay.isKind(of: MKPolyline.self ) {
            
            let lineRender = MKPolylineRenderer.init(overlay: overlay)
            lineRender.lineWidth = 5
            //lineRender.fillColor = UIColor.red
            lineRender.strokeColor = UIColor.purple
            return lineRender
        }
        if overlay.isKind(of: MKCircle.self ) {
            let lineRender = MKCircleRenderer.init(overlay: overlay)
            lineRender.alpha = 0.5
            lineRender.fillColor = UIColor.red
            //lineRender.strokeColor = UIColor.purple
            return lineRender
        }
        
        return MKOverlayRenderer()
    }
    
    //
    func mapViewWillStartLocatingUser(_ mapView: MKMapView){
//        NotificationCenter.default.post(name: DDLocationManager.GDLocationChanged, object: nil, userInfo: nil )
    }
    //
    func mapViewDidStopLocatingUser(_ mapView: MKMapView){
        NotificationCenter.default.post(name: DDLocationManager.GDLocationChanged, object: nil, userInfo: nil )
    }
    //ÂÆûÊó∂Ëé∑ÂèñÁî®Êà∑‰ΩçÁΩÆ‰ª£ÁêÜ
    func mapView(_ mapView: MKMapView, didUpdate userLocation: MKUserLocation){
        mylog("get current location : \(userLocation.coordinate)")
        NotificationCenter.default.post(name: DDLocationManager.GDLocationChanged, object: nil, userInfo: nil )
        //        mapView.setCenter(userLocation.coordinate, animated: true)//ËÆæÁΩÆÂΩìÂâç‰ΩçÁΩÆÂà∞Â±èÂπï‰∏≠ÂøÉ
        if needGobackCenter {
            needGobackCenter = false
            self.settheUserLocationToScreenCenter(location:userLocation)//ÂÆûÊó∂ËÆæÁΩÆÂΩìÂâç‰ΩçÁΩÆÂà∞Â±èÂπï‰∏≠ÂøÉ
        }
    }
    //Èò≤Ê≠¢ÂÜÖÂ≠òÂç†Áî®ËøáÈ´ò//ÂèØÊòØ‰ºöÂØºËá¥3DËßÜËßíÂ§±Êïà
    func mapView(_ mapView: MKMapView, regionDidChangeAnimated animated: Bool) {
        mylog("regionDidChangeAnimated")
        self.mapDidEndMove?()
        /*
         */
        return
        let type = mapView.mapType
        switch (type) {
        case MKMapType.hybrid:
            self.mapView.mapType = MKMapType.standard;
            break;
        case MKMapType.standard:
            //        break //ÊöÇÊó∂‰∏çÊâßË°å‰∏Ä‰∏ã‰ª£Á†Å,Èò≤Ê≠¢Âú®nÊ®°ÊãüÂô®ios9‰∏äÂ¥©Ê∫É , Âú®ÁúüÊú∫‰∏äÊúâÂæÖÈ™åËØÅ
            self.mapView.mapType = MKMapType.hybrid;
            break;
        default:
            break;
        }
        self.mapView.mapType = MKMapType.standard;
    }
    
    //ËøîÂõûÂ§ßÂ§¥ÈíàËßÜÂõæÁöÑ‰ª£ÁêÜ
    public func mapView(_ mapView: MKMapView, viewFor annotation: MKAnnotation) -> MKAnnotationView?{
        if  annotation.coordinate.longitude == mapView.userLocation.coordinate.longitude && annotation.coordinate.latitude == mapView.userLocation.coordinate.latitude {//Áî®Êà∑ÂΩìÂâçÁöÑ‰ΩçÁΩÆÊ≠£Â∏∏ËøîÂõûËìùÂúà
            return nil
        }else{//ÂÖ∂‰ªñÁöÑËøîÂõû(Ëá™ÂÆö‰πâ)Â§ßÂ§¥Èíà
            if let gdLocation  = annotation as? GDLocation {
                if gdLocation.type == GDLocationType.origen {//
                    return returnCustomAnnotationView(mapView, viewFor: annotation)
                }else{
                    return self.returnCustomAnnotationViewWithImage(mapView, viewFor: annotation)
                }
            }else{
                return nil
            }
        }
    }
    func mapView(_ mapView: MKMapView, annotationView view: MKAnnotationView, calloutAccessoryControlTapped control: UIControl)
    {
        mylog("oooooo")
        mylog(control)
        mylog(view)
    }
    @objc func bubbleClick(sender:UIButton)  {
        mylog("xxxx")
        GDAlertView.alert(sender.title(for: UIControl.State.normal), image: nil , time: 2 , complateBlock: nil )
    }
    //ËøîÂõûÂõæÁâáÂ§ßÂ§¥Èíà
    func returnCustomAnnotationViewWithImage(_ mapView: MKMapView, viewFor annotation: MKAnnotation) -> MKAnnotationView? {
        var view : MKAnnotationView?
//        var view = mapView.dequeueReusableAnnotationView(withIdentifier: "CustomPlaceMark1")
//        if view == nil  {
////            view = MKAnnotationView.init(annotation: annotation, reuseIdentifier: "CustomPlaceMark1")
//            view = DDProjectsMapCalloutView.init(annotation: annotation, reuseIdentifier: "CustomPlaceMark1")
//        }
        
        if let gdLocation = annotation as? GDLocation{
            switch gdLocation.type{
            case .image1:
                view = mapView.dequeueReusableAnnotationView(withIdentifier: "image1")
                if view == nil  {
                    view = MKAnnotationView.init(annotation: annotation, reuseIdentifier: "image1")
                }
                let image = UIImage(named: "locationmarker")//Â∑ßÁî®‰∏§‰∏™ÂõæÁâáÈáçÂè†
                view?.image = image
                
                let costomMark = UIButton(frame: CGRect(x: 0, y: 0, width: image?.size.width ?? 33, height: image?.size.height ?? 33))
                costomMark.setBackgroundImage(UIImage(named: "locationmarker"), for: UIControl.State.normal)
                costomMark.isUserInteractionEnabled = false//Ê≥®Èáä‰πãÂêéÈúÄË¶ÅËá™Â∑±ÂÆûÁé∞Ê∞îÊ≥°ÁÇπÂáª‰∫ã‰ª∂
                let title = gdLocation.serialNumber  // Â∫èÂè∑,Áõ¥Êé•ÊòæÁ§∫Âá∫Êù•
                costomMark.setTitle(title, for: UIControl.State.normal)
                costomMark.titleEdgeInsets = UIEdgeInsets(top: -5, left: 0, bottom: 5, right: 0)
                costomMark.titleLabel?.font = UIFont.systemFont(ofSize: 14)
                costomMark.titleLabel?.adjustsFontSizeToFitWidth = true 
                costomMark.adjustsImageWhenHighlighted = false
                costomMark.setTitleColor(UIColor.orange, for: UIControl.State.normal)

                view?.addSubview(costomMark)//Ëá™ÂÆö‰πâÂ§ßÂ§¥ÈíàËßÜÂõæ Âå∫Âà´‰∫éMKAnnotationView.imageËµãÂÄº
//                let label = UILabel()
//                label.text = gdLocation.subtitle//Â∫óÈì∫ÂêçÂ≠ó , ÁÇπÂáªÂºπÂá∫
//                label.backgroundColor = UIColor.orange
//                label.ddSizeToFit(contentInset: UIEdgeInsets(top: 22, left: 22, bottom: 22, right: 22))
//                if label.text != nil {
//                    view?.detailCalloutAccessoryView = label//ÁÇπÂáªÂ§ßÂ§¥ÈíàÂºπÂá∫Ê∞îÊ≥°ÊñáÂ≠ó
//                }
//                view?.detailCalloutAccessoryView?.superview?.backgroundColor = UIColor.red

                
            case .image2:
                
                view = mapView.dequeueReusableAnnotationView(withIdentifier: "image1")
                if view == nil  view = DDProjectsMapCalloutView.init(annotation: annotation, reuseIdentifier: "image2")
                }
                
                view?.image = UIImage(named: "JL_positioning")
                let detailView = UIButton(frame: CGRect(x: 0, y: 0, width: 166, height: 84))
//                let detailView = UIButton(frame: CGRect.zero)
                detailView.setBackgroundImage(UIImage(named: "alreadyassigned"), for: UIControl.State.normal)
                detailView.setTitle(annotation.subtitle ?? "", for: UIControl.State.normal)
                detailView.setTitleColor(UIColor.gray, for: UIControl.State.normal)
//                detailView.sizeToFit()
                detailView.addTarget(self , action: #selector(bubbleClick(sender:)), for: UIControl.Event.touchUpInside)
                detailView.titleLabel?.numberOfLines = 0
        //        detailView.image = UIImage(named:"alreadyassigned")
                detailView.backgroundColor = UIColor.yellow.withAlphaComponent(0.1)
                view?.detailCalloutAccessoryView = detailView
//                view?.leftCalloutAccessoryView = UISwitch()
//                view?.rightCalloutAccessoryView = UISwitch()
//                view?.leftCalloutAccessoryView//rightCalloutAccessoryView//Ê†áÈ¢òÂºπÁ™óÁöÑÂ∑¶Âè≥ËßÜÂõæ
//                view?.detailCalloutAccessoryView = //Ê†áÈ¢òÂºπÁ™óÁöÑsubTitle‰ΩçÁΩÆ
            case .image3:
                
                view = mapView.dequeueReusableAnnotationView(withIdentifier: "image1")
                if view == nil  {
                    view = MKAnnotationView.init(annotation: annotation, reuseIdentifier: "image1")
                }
                view?.image = UIImage(named: "team")
                
                view?.image = UIImage(named: "time")

                //        detailView.image = UIImage(named:"alreadyassigned")
                //                detailView.backgroundColor = UIColor.orange
                view?.leftCalloutAccessoryView = UISwitch()
                view?.rightCalloutAccessoryView = UISwitch()
                
            case .image4:
                
                view = mapView.dequeueReusableAnnotationView(withIdentifier: "image1")
                if view == nil  {
                    view = MKAnnotationView.init(annotation: annotation, reuseIdentifier: "image1")
                }
                view?.image = UIImage(named: "date")
                
            case .image5:
                
                view = mapView.dequeueReusableAnnotationView(withIdentifier: "image1")
                if view == nil  {
                    view = MKAnnotationView.init(annotation: annotation, reuseIdentifier: "image1")
                }
                view?.image = UIImage(named: "takepicture")
                
            default :
                
                view = mapView.dequeueReusableAnnotationView(withIdentifier: "image1")
                if view == nil  {
                    view = MKAnnotationView.init(annotation: annotation, reuseIdentifier: "image1")
                }
                break
            }
        }
        

        
        view?.annotation = annotation
        view?.canShowCallout = true//‰∏çÁî®ÂõæÁâáÁöÑÊó∂ÂÄô‰ΩøÁî® , ÂºπÂá∫Â∏∏ËßÑÁöÑÊñáÂ≠ó
        view?.isDraggable = true
//        let detailView = UIButton(frame: CGRect(x: 0, y: 0, width: 66, height: 44))
//        detailView.setBackgroundImage(UIImage(named: "alreadyassigned"), for: UIControl.State.normal)
//        detailView.setTitle("4", for: UIControl.State.normal)
////        detailView.image = UIImage(named:"alreadyassigned")
//        detailView.backgroundColor = UIColor.orange
//        view?.detailCalloutAccessoryView = detailView
//        view?.leftCalloutAccessoryView = UISwitch()
//        view?.rightCalloutAccessoryView = UISwitch()
        //        view?.leftCalloutAccessoryView/rightCalloutAccessoryView//Ê†áÈ¢òÂºπÁ™óÁöÑÂ∑¶Âè≥ËßÜÂõæ
        //        view.detailCalloutAccessoryView//Ê†áÈ¢òÂºπÁ™óÁöÑsubTitle‰ΩçÁΩÆ
        return view //
    }
    
    //ËøîÂõûÁ≥ªÁªüÂ§ßÂ§¥Èíà,(Âè™ÊòØËá™ÂÆö‰πâÈ¢úËâ≤)
    func returnCustomAnnotationView(_ mapView: MKMapView, viewFor annotation: MKAnnotation) -> MKAnnotationView? {
        var view = mapView.dequeueReusableAnnotationView(withIdentifier: "SystemPlaceMark")
        if view == nil  {
            view = MKPinAnnotationView.init(annotation: annotation, reuseIdentifier: "SystemPlaceMark")
        }
        if let subView  = view as? MKPinAnnotationView {
            subView.annotation = annotation
            subView.canShowCallout = true//‰∏çÁî®ÂõæÁâáÁöÑÊó∂ÂÄô‰ΩøÁî® , ÂºπÂá∫Â∏∏ËßÑÁöÑÊñáÂ≠ó
            subView.animatesDrop = true
            subView.isDraggable = true
            if #available(iOS 9.0, *) {
                subView.pinTintColor = UIColor.red
            } else {
                /**
                 MKPinAnnotationColorRed = 0,
                 MKPinAnnotationColorGreen,
                 MKPinAnnotationColorPurple
                 */
                subView.pinColor = MKPinAnnotationColor.red
            }
            return subView //
        }else{
            return nil  //ÈªòËÆ§ÊòØÁ≥ªÁªü
        }
    }
    
}


class DDMapView: MKMapView {

}
